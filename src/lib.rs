pub mod body {
    use bytes::buf::Buf;
    use prost::Message;
    use warp::{
        filters::body::aggregate,
        reject::{self, Reject, Rejection},
        Filter,
    };

    /// Returns a `Filter` that matches any request and extracts a `Future` of a protobuf encoded body.
    ///
    /// # Note
    ///
    /// # Warning
    ///
    /// This does not have a default size limit, it would be wise to use one to
    /// prevent an overly large request from using too much memory.
    ///
    ///
    /// ```
    /// // Generated by PROST!
    /// #[derive(Clone, PartialEq, ::prost::Message)]
    /// pub struct UserRequest {
    ///     #[prost(string, tag = "1")]
    ///     pub name: std::string::String,
    /// }
    ///
    /// let route = warp::body::content_length_limit(1024 * 16)
    ///             .and(warp::body::proto())
    ///             .map(|user: HelloUser| {
    ///                 format!("Hello {}!\nUserID: {}", user.name, user.id)
    ///             });
    /// ```
    #[derive(Debug)]
    struct ProtobufDeseralizeError {
        cause: Box<dyn std::error::Error + Send + Sync>,
    }

    impl Reject for ProtobufDeseralizeError {}

    pub fn protobuf<T: Message + Send + Default>(
    ) -> impl Filter<Extract = (T,), Error = Rejection> + Copy {
        async fn from_reader<T: Message + Send + Default>(buf: impl Buf) -> Result<T, Rejection> {
            T::decode(buf).map_err(|err| {
                log::debug!("request protobuf body error: {}", err);
                reject::custom(ProtobufDeseralizeError { cause: err.into() })
            })
        }
        aggregate().and_then(from_reader)
    }
}

pub mod reply {
    use bytes::BytesMut;
    use prost::Message;
    use warp::{
        http::{
            header::{HeaderValue, CONTENT_TYPE},
            StatusCode,
        },
        reply::{Reply, Response},
    };

    /// Convert the value into a `Reply` with the value encoded as protobuf.
    ///
    /// The passed value must implement [`prost::Message`][prost]. Many
    ///
    /// [prost]: https://docs.rs/prost
    ///
    /// # Example
    ///
    /// ```
    /// use warp::Filter;
    ///
    /// // Generated by PROST!
    /// //
    /// // Check out the [prost] or [prost-build] crate to add .proto
    /// // generation to your project.
    /// // [prost]: https://docs.rs/prost
    /// // [prost-build]: https://docs.rs/prost-build
    /// //
    /// #[derive(Clone, PartialEq, ::prost::Message)]
    /// pub struct UserResponse {
    ///     #[prost(uint64, tag = "1")]
    ///     pub id: u64,
    /// }
    ///
    /// // GET /user returns a `200 OK` with a serialized UserResponse
    /// // object.
    /// let route = warp::path("user")
    ///     .map(|| {
    ///         let user = UserResponse { id: 42 };
    ///         warp::reply::protobuf(&user)
    ///     });
    /// ```
    ///
    /// # Note
    ///
    /// If a type fails to be serialized into protobuf, the error is logged at the
    /// `error` level, and the returned `impl Reply` will be an empty
    /// `500 Internal Server Error` response.
    pub fn protobuf<T>(val: &T) -> Protobuf
    where
        T: Message,
    {
        // BytesMut will grow as necessary, 8KB seems like a reasonable default
        let mut buf = BytesMut::with_capacity(1024 * 8);
        Protobuf {
            inner: val.encode(&mut buf).map(|_| buf.to_vec()).map_err(|err| {
                log::error!("reply::protobuf error: {}", err);
            }),
        }
    }

    /// A Protobuf formatted reply.
    #[allow(missing_debug_implementations)]
    pub struct Protobuf {
        inner: Result<Vec<u8>, ()>,
    }

    impl Reply for Protobuf {
        #[inline]
        fn into_response(self) -> Response {
            match self.inner {
                Ok(body) => {
                    let mut res = Response::new(body.into());
                    res.headers_mut().insert(
                        CONTENT_TYPE,
                        HeaderValue::from_static("application/x-protobuf"),
                    );
                    res
                }
                Err(()) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),
            }
        }
    }

    #[derive(Debug)]
    pub(crate) struct ReplyProtobufError;

    impl std::fmt::Display for ReplyProtobufError {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.write_str("warp::reply::protobuf() failed")
        }
    }

    impl std::error::Error for ReplyProtobufError {}
}
