pub mod filters {
    pub mod body {
        use bytes::buf::Buf;
        use prost::Message;
        use warp::{
            filters::{body::aggregate, log::},
            reject::{self, Reject, Rejection},
            Filter,
        };

        /// Returns a `Filter` that matches any request and extracts a `Future` of a protobuf encoded body.
        ///
        /// # Note
        ///
        /// # Warning
        ///
        /// This does not have a default size limit, it would be wise to use one to
        /// prevent an overly large request from using too much memory.
        ///
        ///
        /// ```
        /// // Generated by PROST!
        /// #[derive(Clone, PartialEq, ::prost::Message)]
        /// pub struct UserRequest {
        ///     #[prost(string, tag = "1")]
        ///     pub name: std::string::String,
        /// }
        ///
        /// let route = warp::body::content_length_limit(1024 * 16)
        ///             .and(warp::body::proto())
        ///             .map(|user: HelloUser| {
        ///                 format!("Hello {}!\nUserID: {}", user.name, user.id)
        ///             });
        /// ```
        #[derive(Debug)]
        struct ProtobufDeseralizeError {
            cause: Box<dyn std::error::Error + Send + Sync>,
        }

        impl Reject for ProtobufDeseralizeError {}

        pub fn protobuf<T: Message + Send + Default>(
        ) -> impl Filter<Extract = (T,), Error = Rejection> + Copy {
            async fn from_reader<T: Message + Send + Default>(
                buf: impl Buf,
            ) -> Result<T, Rejection> {
                T::decode(buf).map_err(|err| {
                    log::debug!("request protobuf body error: {}", err);
                    reject::custom(ProtobufDeseralizeError { cause: err.into() })
                })
            }
            aggregate().and_then(from_reader)
        }
    }
}
